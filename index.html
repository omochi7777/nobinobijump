<!DOCTYPE html>
<html lang="ja">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>„Åü„Å≠„ÅÆ„ÅÆ„Å≥„ÅÆ„Å≥„Ç∏„É£„É≥„ÉóDX</title>
  <link rel="icon" type="image/png" href="favicon.png">
  <link rel="apple-touch-icon" href="favicon.png">
  <style>
    body {
      margin: 0;
      overflow: hidden;
      background-color: #87CEEB;
      font-family: "M PLUS Rounded 1c", sans-serif;
      user-select: none;
      -webkit-user-select: none;
      touch-action: none;
    }

    #canvas-container {
      width: 100%;
      height: 100vh;
      display: block;
    }

    #ui-layer {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      display: flex;
      flex-direction: column;
      justify-content: space-between;
    }

    #header-ui {
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      padding: 20px;
      font-weight: bold;
      color: white;
      text-shadow: 2px 2px 0 #000;
    }

    #score-display {
      font-size: 28px;
    }

    #right-ui {
      display: flex;
      flex-direction: column;
      align-items: flex-end;
      gap: 10px;
    }

    #highscore-display {
      font-size: 20px;
      color: #ffd700;
      text-align: right;
    }

    #pause-btn {
      pointer-events: auto;
      background: rgba(255, 255, 255, 0.3);
      border: 3px solid #fff;
      color: white;
      font-size: 24px;
      width: 50px;
      height: 50px;
      border-radius: 50%;
      cursor: pointer;
      font-family: inherit;
      font-weight: bold;
      text-shadow: 2px 2px 0 #000;
      display: flex;
      align-items: center;
      justify-content: center;
      backdrop-filter: blur(4px);
      transition: transform 0.1s, background 0.2s;
    }

    #pause-btn:hover {
      background: rgba(255, 255, 255, 0.5);
    }

    #pause-btn:active {
      transform: scale(0.9);
    }

    /* Pause Overlay */
    #pause-overlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.7);
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      color: white;
      z-index: 5;
      pointer-events: auto;
      backdrop-filter: blur(6px);
    }

    #pause-overlay h2 {
      font-size: 48px;
      margin: 0 0 20px 0;
      text-shadow: 3px 3px 0 #5bc656;
    }

    #pause-overlay p {
      font-size: 18px;
      color: #aaa;
      margin-bottom: 30px;
    }

    #resume-btn {
      background: #7bc656;
      border: 4px solid #fff;
      color: white;
      font-size: 20px;
      padding: 15px 40px;
      border-radius: 50px;
      cursor: pointer;
      font-family: inherit;
      font-weight: bold;
      box-shadow: 0 4px 0 rgba(0, 0, 0, 0.2);
      transition: transform 0.1s;
    }

    #resume-btn:active {
      transform: scale(0.95);
      box-shadow: 0 2px 0 rgba(0, 0, 0, 0.2);
    }

    /* Message Overlay */
    #message-area {
      position: absolute;
      top: 30%;
      width: 100%;
      text-align: center;
      pointer-events: none;
    }

    .milestone-msg {
      font-size: 48px;
      font-weight: bold;
      color: #ffeb3b;
      text-shadow: 4px 4px 0 #ff5722, -2px -2px 0 #fff;
      opacity: 0;
      transform: scale(0.5);
      animation: popIn 2.5s forwards;
      display: inline-block;
      white-space: nowrap;
    }

    /* 10000m Special Style */
    .legend-msg {
      font-size: 60px;
      background: linear-gradient(to right, #e6b980 20%, #eacda3 40%, #d6ae7b 60%, #eacda3 80%);
      -webkit-background-clip: text;
      background-clip: text;
      color: transparent;
      text-shadow: 0 0 20px rgba(255, 215, 0, 0.8);
      animation: popIn 3s forwards, shine 2s linear infinite;
    }

    @keyframes popIn {
      0% {
        opacity: 0;
        transform: scale(0.5) translateY(20px);
      }

      10% {
        opacity: 1;
        transform: scale(1.2) translateY(0);
      }

      80% {
        opacity: 1;
        transform: scale(1.0);
      }

      100% {
        opacity: 0;
        transform: scale(1.5);
      }
    }

    @keyframes shine {
      to {
        background-position: 200% center;
      }
    }

    #menu-screen {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.6);
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      color: white;
      z-index: 10;
      pointer-events: auto;
      backdrop-filter: blur(4px);
    }

    h1 {
      margin: 0;
      font-size: 40px;
      text-shadow: 3px 3px 0 #5bc656;
      color: #fff;
      text-align: center;
    }

    .subtitle {
      font-size: 24px;
      color: #ffd700;
      text-shadow: 2px 2px 0 #000;
      margin-bottom: 10px;
    }

    p {
      font-size: 16px;
      margin: 10px 0 30px;
      text-align: center;
      line-height: 1.5;
    }

    button {
      background: #ff9999;
      border: 4px solid #fff;
      color: white;
      font-size: 20px;
      padding: 15px 40px;
      border-radius: 50px;
      cursor: pointer;
      font-family: inherit;
      font-weight: bold;
      box-shadow: 0 4px 0 rgba(0, 0, 0, 0.2);
      transition: transform 0.1s;
    }

    button:active {
      transform: scale(0.95);
      box-shadow: 0 2px 0 rgba(0, 0, 0, 0.2);
    }

    .hidden {
      display: none !important;
    }

    /* Mobile touch hint */
    #touch-hint {
      position: absolute;
      bottom: 80px;
      width: 100%;
      text-align: center;
      color: rgba(255, 255, 255, 0.7);
      font-size: 14px;
      pointer-events: none;
    }

    /* Countdown overlay */
    #countdown-overlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.5);
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 15;
      pointer-events: none;
      backdrop-filter: blur(2px);
    }

    .countdown-number {
      font-size: 150px;
      font-weight: bold;
      color: #fff;
      text-shadow: 0 0 30px rgba(255, 255, 255, 0.8), 4px 4px 0 #5bc656;
      animation: countdownPop 0.8s ease-out forwards;
    }

    .countdown-go {
      font-size: 60px;
      white-space: nowrap;
      background: linear-gradient(135deg, #ff9999, #ffeb3b, #7bc656);
      -webkit-background-clip: text;
      background-clip: text;
      color: transparent;
      text-shadow: none;
      filter: drop-shadow(4px 4px 0 rgba(0, 0, 0, 0.3));
    }

    @keyframes countdownPop {
      0% {
        opacity: 0;
        transform: scale(2);
      }

      20% {
        opacity: 1;
        transform: scale(1);
      }

      80% {
        opacity: 1;
        transform: scale(1);
      }

      100% {
        opacity: 0;
        transform: scale(0.5);
      }
    }
  </style>
  <link href="https://fonts.googleapis.com/css2?family=M+PLUS+Rounded+1c:wght@400;700&display=swap" rel="stylesheet">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
</head>

<body>

  <div id="canvas-container"></div>

  <div id="ui-layer">
    <div id="header-ui">
      <div id="score-display">È´ò„Åï: 0m</div>
      <div id="right-ui">
        <div id="highscore-display">BEST: 0m</div>
        <button id="pause-btn" class="hidden">‚è∏</button>
      </div>
    </div>
    <div id="message-area"></div>
    <div id="touch-hint"></div>
  </div>

  <div id="pause-overlay" class="hidden">
    <h2>‚è∏ ‰∏ÄÊôÇÂÅúÊ≠¢</h2>
    <p>„Å°„Çá„Å£„Å®‰ºëÊÜ©...</p>
    <button id="resume-btn">‚ñ∂ „Å§„Å•„Åë„Çã</button>
  </div>

  <div id="countdown-overlay" class="hidden">
    <div id="countdown-text"></div>
  </div>

  <div id="menu-screen">
    <h1>„Åü„Å≠„ÅÆ<br>„ÅÆ„Å≥„ÅÆ„Å≥„Ç∏„É£„É≥„Éó</h1>
    <div class="subtitle">DX</div>
    <p>„Å©„Åì„Åæ„Åß„ÇÇÈ´ò„ÅèÔºÅ<br>„Éè„Ç§„Çπ„Ç≥„Ç¢„ÇíÁõÆÊåá„Åù„ÅÜ</p>
    <button id="start-btn">„Çπ„Çø„Éº„Éà</button>
  </div>

  <script>
    let scene, camera, renderer;
    let taneGroup;
    let platforms = [];
    let particles = [];
    let clouds = [];

    // ============ SHARED GEOMETRIES & MATERIALS (Performance optimization) ============
    // Pre-created geometries and materials for reuse to reduce GC pressure
    const sharedGeometries = {};
    const sharedMaterials = {};

    // ============ OBJECT POOLS (Prevent GC pressure from long play sessions) ============
    const particlePool = [];      // Pool of reusable particle objects
    const platformPool = [];      // Pool of reusable platform groups
    const MAX_PARTICLES = 50;     // Maximum particles to keep in pool
    const MAX_PLATFORMS = 20;     // Maximum platforms to keep in pool

    // Reusable Vector3 for particle velocity (avoid creating new objects)
    const tempVelocity = new THREE.Vector3();

    // Default scale vector for lerp (avoid creating new Vector3 each frame)
    const DEFAULT_SCALE = new THREE.Vector3(1, 1, 1);

    let gameActive = false;
    let gamePaused = false;
    let score = 0;
    let highScore = 0;
    let highestY = 0;

    let playerVelocityY = 0;
    const GRAVITY = 0.012;
    const JUMP_FORCE = 0.38;

    let cameraTargetY = 2;
    let targetX = 0;

    // Audio Context for sound effects
    let audioCtx = null;


    // Check if mobile
    const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);

    // Milestones - More frequent messages for more fun!
    const milestones = [
      // Early game - Frequent encouragement
      { height: 10, msg: "„ÅÑ„ÅÑ„Å≠ÔºÅ", shown: false },
      { height: 20, msg: "„Åù„ÅÆË™øÂ≠êÔºÅ", shown: false },
      { height: 30, msg: "„ÅÆ„Å≥„ÅÆ„Å≥„Äú", shown: false },
      { height: 50, msg: "„Åô„Åî„ÅÑÔºÅ", shown: false },
      { height: 75, msg: "Áµ∂Â•ΩË™øÔºÅ", shown: false },
      { height: 100, msg: "üéâ100mÁ™ÅÁ†¥ÔºÅ", shown: false },

      // Mid game - Building excitement
      { height: 125, msg: "„Åæ„Å†„Åæ„Å†ÔºÅ", shown: false },
      { height: 150, msg: "Èõ≤„Å´Ëøë„Å•„ÅÑ„Å¶„Åç„Åü", shown: false },
      { height: 175, msg: "„ÅÑ„ÅÑÊÑü„Åò‚ô™", shown: false },
      { height: 200, msg: "‚òÅÔ∏èÈõ≤„ÅÆ‰∏ä„Å†ÔºÅ", shown: false },
      { height: 250, msg: "Á©∫„ÅåÂ∫É„ÅÑÔºÅ", shown: false },
      { height: 300, msg: "üöÄÂÆáÂÆô„Å∏ÔºÅ", shown: false },
      { height: 350, msg: "Âú∞ÁêÉ„ÅåÂ∞è„Åï„Åè...", shown: false },
      { height: 400, msg: "Êòü„ÅåË¶ã„Åà„Å¶„Åç„Åü", shown: false },
      { height: 500, msg: "üåüÂ§ßÊ∞óÂúèÁ™ÅÁ†¥ÔºÅ", shown: false },

      // High altitude - Achievements
      { height: 600, msg: "„Å©„Çì„Å©„ÇìË°å„Åì„ÅÜÔºÅ", shown: false },
      { height: 700, msg: "Ê≠¢„Åæ„Çâ„Å™„ÅÑÔºÅ", shown: false },
      { height: 800, msg: "‚≠êÊòü„Å´„Å™„Å£„ÅüÔºÅ", shown: false },
      { height: 900, msg: "„ÇÇ„ÅÜ„Åô„Åê1000mÔºÅ", shown: false },
      { height: 1000, msg: "üèÜ1000mÂà∞ÈÅîÔºÅ", shown: false },

      // Expert zone
      { height: 1250, msg: "ÈäÄÊ≤≥„ÅÆÂÖ•„ÇäÂè£", shown: false },
      { height: 1500, msg: "üååÈäÄÊ≤≥„ÅÆÊóÖ‰∫∫", shown: false },
      { height: 1750, msg: "„Åô„Åî„Åô„Åé„ÇãÔºÅ", shown: false },
      { height: 2000, msg: "üõ∏„Å©„Åì„Åæ„ÅßË°å„Åè„ÅÆÔºü", shown: false },
      { height: 2500, msg: "Áï∞Ê¨°ÂÖÉ„ÅÆ‰∏ñÁïå...", shown: false },
      { height: 3000, msg: "üî•Ââç‰∫∫Êú™Âà∞ÔºÅ", shown: false },
      { height: 3500, msg: "‰ºùË™¨„ÅÆÂßã„Åæ„Çä", shown: false },
      { height: 4000, msg: "üëºÁ•û„ÅÆÈ†òÂüüÔºÅ", shown: false },
      { height: 4500, msg: "ÈôêÁïå„ÇíË∂Ö„Åà„ÅüÔºÅ", shown: false },
      { height: 5000, msg: "‚ú®Áúü„ÅÆ‰ºùË™¨ÈÅîÊàê‚ú®", shown: false },

      // Ultra zone
      { height: 6000, msg: "üåàÈôêÁïåÁ™ÅÁ†¥ÔºÅÔºÅ", shown: false },
      { height: 7000, msg: "Ê¨°ÂÖÉ„ÇíË∂ÖË∂ä...", shown: false },
      { height: 8000, msg: "üåÄÊú™Áü•„ÅÆÊ¨°ÂÖÉ„Å∏", shown: false },
      { height: 9000, msg: "„ÇÇ„ÅÜ„Åô„ÅêÈ†ÇÁÇπÔºÅ", shown: false },
      { height: 10000, msg: "üëëÂÆáÂÆô„ÅÆË¶áËÄÖüëë", shown: false, isLegend: true },

      // Beyond 10000m - Ultimate achievements
      { height: 12000, msg: "üåüÊôÇÁ©∫„ÇíË∂Ö„Åà„ÅüÂ≠òÂú®", shown: false, isLegend: true },
      { height: 15000, msg: "üí´ÂâµÈÄ†‰∏ª„É¨„Éô„É´", shown: false, isLegend: true },
      { height: 20000, msg: "üî±Á•û„Çí„ÇÇË∂Ö„Åà„ÅüÔºÅ", shown: false, isLegend: true },
      { height: 25000, msg: "‚ú®‚àûÁÑ°Èôê„ÅÆÂΩºÊñπ„Å∏‚àû‚ú®", shown: false, isLegend: true },
      { height: 30000, msg: "üèÖÁ©∂Ê•µ„ÅÆÂà∞ÈÅîÁÇπ", shown: false, isLegend: true },
      { height: 50000, msg: "üëëüëëÂÖ®ÂÆáÂÆô„ÅÆÊîØÈÖçËÄÖüëëüëë", shown: false, isLegend: true },
      { height: 100000, msg: "üéä„Åä„ÇÅ„Åß„Å®„ÅÜÔºÅÂÆåÂÖ®Âà∂Ë¶áüéä", shown: false, isLegend: true }
    ];

    const colors = {
      body: 0xffffff,
      cheek: 0xff9999,
      sprout: 0x7bc656,
      eye: 0x222222,
      leaf: 0x81c784,
      leafDark: 0x2e7d32,
      skyStart: new THREE.Color(0x87CEEB),
      skyEnd: new THREE.Color(0x050510) // Dark space
    };

    // ============ SOUND EFFECTS ============
    function initAudio() {
      if (!audioCtx) {
        audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      }
      if (audioCtx.state === 'suspended') {
        audioCtx.resume();
      }
    }

    function playJumpSound() {
      if (!audioCtx) return;

      const osc = audioCtx.createOscillator();
      const gain = audioCtx.createGain();

      osc.connect(gain);
      gain.connect(audioCtx.destination);

      // "Poyon" bounce sound - pitch goes up then down
      osc.type = 'sine';
      osc.frequency.setValueAtTime(300, audioCtx.currentTime);
      osc.frequency.exponentialRampToValueAtTime(600, audioCtx.currentTime + 0.08);
      osc.frequency.exponentialRampToValueAtTime(250, audioCtx.currentTime + 0.2);

      gain.gain.setValueAtTime(0.3, audioCtx.currentTime);
      gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.25);

      // Cleanup after sound ends to prevent memory leak
      osc.onended = () => {
        osc.disconnect();
        gain.disconnect();
      };

      osc.start(audioCtx.currentTime);
      osc.stop(audioCtx.currentTime + 0.25);
    }

    function playGameOverSound() {
      if (!audioCtx) return;

      const osc = audioCtx.createOscillator();
      const gain = audioCtx.createGain();

      osc.connect(gain);
      gain.connect(audioCtx.destination);

      osc.type = 'triangle';
      osc.frequency.setValueAtTime(400, audioCtx.currentTime);
      osc.frequency.exponentialRampToValueAtTime(100, audioCtx.currentTime + 0.5);

      gain.gain.setValueAtTime(0.3, audioCtx.currentTime);
      gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.5);

      // Cleanup after sound ends to prevent memory leak
      osc.onended = () => {
        osc.disconnect();
        gain.disconnect();
      };

      osc.start(audioCtx.currentTime);
      osc.stop(audioCtx.currentTime + 0.5);
    }

    function playMilestoneSound() {
      if (!audioCtx) return;

      const notes = [523, 659, 784]; // C5, E5, G5
      notes.forEach((freq, i) => {
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();

        osc.connect(gain);
        gain.connect(audioCtx.destination);

        osc.type = 'sine';
        osc.frequency.value = freq;

        const startTime = audioCtx.currentTime + i * 0.1;
        gain.gain.setValueAtTime(0, startTime);
        gain.gain.linearRampToValueAtTime(0.2, startTime + 0.05);
        gain.gain.exponentialRampToValueAtTime(0.01, startTime + 0.3);

        // Cleanup after sound ends to prevent memory leak
        osc.onended = () => {
          osc.disconnect();
          gain.disconnect();
        };

        osc.start(startTime);
        osc.stop(startTime + 0.3);
      });
    }

    // ============ PAUSE FUNCTIONALITY ============
    function togglePause() {
      if (!gameActive) return;

      gamePaused = !gamePaused;

      if (gamePaused) {
        document.getElementById('pause-overlay').classList.remove('hidden');
        document.getElementById('pause-btn').innerText = '‚ñ∂';
      } else {
        document.getElementById('pause-overlay').classList.add('hidden');
        document.getElementById('pause-btn').innerText = '‚è∏';
      }
    }

    function initSharedResources() {
      // Particle geometry and material (shared across all particles)
      sharedGeometries.particle = new THREE.SphereGeometry(0.1, 4, 4);
      sharedMaterials.particle = new THREE.MeshBasicMaterial({ color: 0xffffff });

      // Platform geometry and materials
      sharedGeometries.platform = new THREE.CylinderGeometry(1.2, 1.2, 0.2, 16);
      sharedGeometries.platformRing = new THREE.TorusGeometry(1.2, 0.05, 8, 24);
      sharedMaterials.platform = new THREE.MeshLambertMaterial({ color: colors.leaf });
      sharedMaterials.platformRing = new THREE.MeshBasicMaterial({ color: colors.leafDark });

      // Cloud geometry and material
      sharedGeometries.cloud = new THREE.SphereGeometry(1, 16, 16);
      sharedMaterials.cloud = new THREE.MeshLambertMaterial({ color: 0xffffff, transparent: true, opacity: 0.8 });
    }

    function init() {
      const savedScore = localStorage.getItem('taneJumpHighScore');
      if (savedScore) {
        highScore = parseInt(savedScore);
        document.getElementById('highscore-display').innerText = `BEST: ${highScore}m`;
      }

      const container = document.getElementById('canvas-container');

      scene = new THREE.Scene();
      scene.background = colors.skyStart.clone();
      scene.fog = new THREE.Fog(colors.skyStart.clone(), 10, 40);

      // Initialize shared geometries and materials
      initSharedResources();

      camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 100);
      camera.position.set(0, 2, 12);

      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.shadowMap.enabled = true;
      renderer.shadowMap.type = THREE.SoftShadowMap;
      container.appendChild(renderer.domElement);

      const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
      scene.add(ambientLight);

      const dirLight = new THREE.DirectionalLight(0xffffff, 0.6);
      dirLight.position.set(10, 20, 10);
      dirLight.castShadow = true;
      scene.add(dirLight);

      createClouds();
      createCharacter();
      resetGame();

      window.addEventListener('resize', onWindowResize, false);

      // Mouse control (PC)
      const updateTargetX = (clientX) => {
        const normX = (clientX / window.innerWidth) * 2 - 1;
        // Narrower range to keep player visible on screen
        targetX = normX * 4;
      };

      document.addEventListener('mousemove', e => {
        if (gameActive && !gamePaused) updateTargetX(e.clientX);
      });

      // Touch control (Mobile)
      document.addEventListener('touchmove', e => {
        if (gameActive && !gamePaused) {
          e.preventDefault();
          updateTargetX(e.touches[0].clientX);
        }
      }, { passive: false });

      // Keyboard pause (P key or Escape)
      document.addEventListener('keydown', e => {
        if ((e.key === 'p' || e.key === 'P' || e.key === 'Escape') && gameActive) {
          togglePause();
        }
      });

      // Auto-pause when tab becomes hidden (prevents player from falling when switching tabs)
      document.addEventListener('visibilitychange', () => {
        if (document.hidden && gameActive && !gamePaused) {
          togglePause();
        }
      });

      // Pause button
      document.getElementById('pause-btn').addEventListener('click', togglePause);
      document.getElementById('resume-btn').addEventListener('click', togglePause);

      document.getElementById('start-btn').addEventListener('click', startGame);

      // Mobile hint
      if (isMobile) {
        document.getElementById('touch-hint').innerText = 'üëÜ „Çø„ÉÉ„Éó„Åß„Çπ„Çø„Éº„Éà';
      }

      animate();
    }

    function createCapsuleMesh(radius, length, color) {
      const group = new THREE.Group();
      const material = new THREE.MeshLambertMaterial({ color: color });
      const cylinder = new THREE.Mesh(new THREE.CylinderGeometry(radius, radius, length, 12), material);
      cylinder.castShadow = true; group.add(cylinder);
      const top = new THREE.Mesh(new THREE.SphereGeometry(radius, 12, 12), material);
      top.position.y = length / 2; top.castShadow = true; group.add(top);
      const bot = new THREE.Mesh(new THREE.SphereGeometry(radius, 12, 12), material);
      bot.position.y = -length / 2; bot.castShadow = true; group.add(bot);
      return group;
    }

    function createCharacter() {
      taneGroup = new THREE.Group();
      scene.add(taneGroup);

      const head = new THREE.Mesh(new THREE.SphereGeometry(0.6, 24, 24), new THREE.MeshLambertMaterial({ color: colors.body }));
      head.position.y = 0.4; head.castShadow = true; taneGroup.add(head);

      const eyeGeo = new THREE.SphereGeometry(0.06, 8, 8);
      const eyeMat = new THREE.MeshLambertMaterial({ color: colors.eye });
      const lEye = new THREE.Mesh(eyeGeo, eyeMat); lEye.position.set(-0.2, 0.45, 0.5); head.add(lEye);
      const rEye = new THREE.Mesh(eyeGeo, eyeMat); rEye.position.set(0.2, 0.45, 0.5); head.add(rEye);

      const cheekGeo = new THREE.CircleGeometry(0.12, 16);
      const cheekMat = new THREE.MeshBasicMaterial({ color: colors.cheek });
      const lCheek = new THREE.Mesh(cheekGeo, cheekMat); lCheek.position.set(-0.35, 0.35, 0.45); lCheek.rotation.y = -0.5; head.add(lCheek);
      const rCheek = new THREE.Mesh(cheekGeo, cheekMat); rCheek.position.set(0.35, 0.35, 0.45); rCheek.rotation.y = 0.5; head.add(rCheek);

      const stem = new THREE.Mesh(new THREE.CylinderGeometry(0.02, 0.02, 0.2, 8), eyeMat);
      stem.position.y = 1.0; taneGroup.add(stem);
      const leafGeo = new THREE.SphereGeometry(0.1, 8, 8); leafGeo.scale(1, 0.3, 1);
      const leafMat = new THREE.MeshLambertMaterial({ color: colors.sprout });
      const lLeaf = new THREE.Mesh(leafGeo, leafMat); lLeaf.position.set(-0.08, 1.1, 0); lLeaf.rotation.z = 0.5; taneGroup.add(lLeaf);
      const rLeaf = new THREE.Mesh(leafGeo, leafMat); rLeaf.position.set(0.08, 1.1, 0); rLeaf.rotation.z = -0.5; taneGroup.add(rLeaf);

      const body = createCapsuleMesh(0.35, 0.3, colors.body);
      body.position.y = -0.2; taneGroup.add(body);
    }

    function createClouds() {
      for (let i = 0; i < 20; i++) {
        // Reuse shared geometry and material, use scale for size variation
        const cloud = new THREE.Mesh(sharedGeometries.cloud, sharedMaterials.cloud);
        const scale = Math.random() * 2 + 1;
        cloud.scale.set(scale, scale, scale);
        cloud.position.set(
          (Math.random() - 0.5) * 40,
          (Math.random() - 0.5) * 40,
          -15 - Math.random() * 10
        );
        scene.add(cloud);
        clouds.push(cloud);
      }
    }

    function createPlatform(x, y) {
      let group;

      // Try to reuse from pool first
      if (platformPool.length > 0) {
        group = platformPool.pop();
      } else {
        // Create new platform only if pool is empty
        group = new THREE.Group();
        const mesh = new THREE.Mesh(sharedGeometries.platform, sharedMaterials.platform);
        mesh.receiveShadow = true;
        group.add(mesh);
        const ring = new THREE.Mesh(sharedGeometries.platformRing, sharedMaterials.platformRing);
        ring.rotation.x = Math.PI / 2;
        group.add(ring);
      }

      group.position.set(x, y, 0);
      scene.add(group);
      return { mesh: group, x: x, y: y };
    }

    // Return platform to pool for reuse
    function recyclePlatform(platform) {
      scene.remove(platform.mesh);
      if (platformPool.length < MAX_PLATFORMS) {
        platformPool.push(platform.mesh);
      }
    }

    function startGame() {
      // Initialize audio on first user interaction
      initAudio();

      document.getElementById('menu-screen').classList.add('hidden');
      document.getElementById('touch-hint').innerText = '';

      resetGame();

      // Start countdown
      startCountdown();
    }

    function startCountdown() {
      const overlay = document.getElementById('countdown-overlay');
      const textEl = document.getElementById('countdown-text');

      overlay.classList.remove('hidden');

      const sequence = [
        { text: '3', isGo: false },
        { text: '2', isGo: false },
        { text: '1', isGo: false },
        { text: '„Çπ„Çø„Éº„ÉàÔºÅ', isGo: true }
      ];

      let index = 0;

      function showNext() {
        if (index >= sequence.length) {
          // Countdown finished, start the game!
          overlay.classList.add('hidden');
          document.getElementById('pause-btn').classList.remove('hidden');
          gameActive = true;
          gamePaused = false;
          playerVelocityY = JUMP_FORCE;
          playJumpSound();
          return;
        }

        const item = sequence[index];

        // Reset animation by removing class, forcing reflow, then adding class back
        textEl.className = '';
        textEl.innerText = item.text;
        void textEl.offsetWidth; // Force reflow to restart animation
        textEl.className = item.isGo ? 'countdown-number countdown-go' : 'countdown-number';

        // Play countdown sound
        if (!item.isGo) {
          playCountdownSound();
        } else {
          playStartSound();
        }

        index++;
        setTimeout(showNext, 800);
      }

      showNext();
    }

    function playCountdownSound() {
      if (!audioCtx) return;

      const osc = audioCtx.createOscillator();
      const gain = audioCtx.createGain();

      osc.connect(gain);
      gain.connect(audioCtx.destination);

      osc.type = 'sine';
      osc.frequency.value = 440; // A4

      gain.gain.setValueAtTime(0.2, audioCtx.currentTime);
      gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.15);

      // Cleanup after sound ends to prevent memory leak
      osc.onended = () => {
        osc.disconnect();
        gain.disconnect();
      };

      osc.start(audioCtx.currentTime);
      osc.stop(audioCtx.currentTime + 0.15);
    }

    function playStartSound() {
      if (!audioCtx) return;

      // Play a cheerful ascending chord
      const notes = [523, 659, 784, 1047]; // C5, E5, G5, C6
      notes.forEach((freq, i) => {
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();

        osc.connect(gain);
        gain.connect(audioCtx.destination);

        osc.type = 'sine';
        osc.frequency.value = freq;

        const startTime = audioCtx.currentTime + i * 0.05;
        gain.gain.setValueAtTime(0, startTime);
        gain.gain.linearRampToValueAtTime(0.15, startTime + 0.05);
        gain.gain.exponentialRampToValueAtTime(0.01, startTime + 0.4);

        // Cleanup after sound ends to prevent memory leak
        osc.onended = () => {
          osc.disconnect();
          gain.disconnect();
        };

        osc.start(startTime);
        osc.stop(startTime + 0.4);
      });
    }

    function resetGame() {
      // Return all platforms to pool before clearing
      platforms.forEach(p => {
        scene.remove(p.mesh);
        if (platformPool.length < MAX_PLATFORMS) {
          platformPool.push(p.mesh);
        }
      });
      platforms = [];

      taneGroup.position.set(0, 0, 0);
      taneGroup.rotation.set(0, 0, 0);
      playerVelocityY = 0;
      targetX = 0;
      highestY = 0;
      score = 0;
      camera.position.y = 2;
      cameraTargetY = 2;

      milestones.forEach(m => m.shown = false);
      document.getElementById('message-area').innerHTML = '';
      scene.fog.near = 10;
      scene.fog.far = 40;

      platforms.push(createPlatform(0, -2));
      for (let i = 0; i < 10; i++) generateNextPlatform();

      updateScore();
      updateBackground(0);
    }

    function generateNextPlatform() {
      const lastY = platforms.length > 0 ? platforms[platforms.length - 1].y : -2;
      const deltaY = 1.5 + Math.random() * 1.5;
      // Narrower range to keep platforms visible on screen
      let newX = (Math.random() - 0.5) * 5;
      platforms.push(createPlatform(newX, lastY + deltaY));
    }

    function showMessage(text, isLegend = false) {
      const container = document.getElementById('message-area');
      const el = document.createElement('div');
      el.className = isLegend ? 'legend-msg' : 'milestone-msg';
      el.innerText = text;
      container.appendChild(el);
      setTimeout(() => { if (el.parentNode) el.parentNode.removeChild(el); }, isLegend ? 4000 : 2500);
    }

    function gameOver() {
      gameActive = false;
      gamePaused = false;

      playGameOverSound();

      document.getElementById('pause-btn').classList.add('hidden');
      document.getElementById('pause-overlay').classList.add('hidden');

      if (score > highScore) {
        highScore = score;
        localStorage.setItem('taneJumpHighScore', highScore);
        document.getElementById('highscore-display').innerText = `BEST: ${highScore}m`;
        showMessage("Ëá™Â∑±„Éô„Çπ„ÉàÊõ¥Êñ∞ÔºÅ");
      }

      const menu = document.getElementById('menu-screen');
      menu.classList.remove('hidden');
      menu.querySelector('h1').innerText = "„Ç≤„Éº„É†„Ç™„Éº„Éê„Éº";
      menu.querySelector('.subtitle').innerText = "";
      menu.querySelector('p').innerHTML = `Ë®òÈå≤: ${score}m<br>„Éô„Çπ„Éà: ${highScore}m`;
      menu.querySelector('button').innerText = "„É™„Éà„É©„Ç§";
    }

    function spawnParticles(pos) {
      for (let i = 0; i < 5; i++) {
        let particleObj;

        // Try to reuse from pool first
        if (particlePool.length > 0) {
          particleObj = particlePool.pop();
          particleObj.mesh.position.copy(pos);
          particleObj.mesh.position.y -= 0.5;
          particleObj.mesh.scale.set(1, 1, 1);
          particleObj.mesh.visible = true;
          // Reuse existing velocity vector
          particleObj.vel.set(
            (Math.random() - 0.5) * 0.2,
            Math.random() * 0.2,
            (Math.random() - 0.5) * 0.2
          );
          particleObj.life = 20;
          scene.add(particleObj.mesh);
        } else {
          // Create new particle only if pool is empty
          const mesh = new THREE.Mesh(sharedGeometries.particle, sharedMaterials.particle);
          mesh.position.copy(pos);
          mesh.position.y -= 0.5;
          mesh.scale.set(1, 1, 1);
          scene.add(mesh);
          particleObj = {
            mesh: mesh,
            vel: new THREE.Vector3(
              (Math.random() - 0.5) * 0.2,
              Math.random() * 0.2,
              (Math.random() - 0.5) * 0.2
            ),
            life: 20
          };
        }

        particles.push(particleObj);
      }
    }

    // Return particle to pool for reuse
    function recycleParticle(particleObj) {
      scene.remove(particleObj.mesh);
      particleObj.mesh.visible = false;
      if (particlePool.length < MAX_PARTICLES) {
        particlePool.push(particleObj);
      }
    }

    function updateScore() {
      const currentHeight = Math.floor(Math.max(0, highestY));
      if (currentHeight > score) {
        score = currentHeight;
        document.getElementById('score-display').innerText = `È´ò„Åï: ${score}m`;

        milestones.forEach(m => {
          if (!m.shown && score >= m.height) {
            showMessage(m.msg, m.isLegend);
            playMilestoneSound();
            m.shown = true;
          }
        });

        updateBackground(score);
      }
    }

    function updateBackground(height) {
      // Gradient to deep space - completes at 1000m, stays dark after
      const ratio = Math.min(Math.max(height / 1000, 0), 1);

      // Use Color.lerp() for cleaner, more efficient color interpolation
      scene.background.copy(colors.skyStart).lerp(colors.skyEnd, ratio);
      scene.fog.color.copy(scene.background);

      // Adjust fog density for high altitude (make it less dense in space)
      if (height > 500) {
        scene.fog.far = 40 + Math.min(height / 100, 60); // Increase fog distance
      }
    }

    function onWindowResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function animate() {
      requestAnimationFrame(animate);

      // Skip game logic if paused
      if (gameActive && gamePaused) {
        renderer.render(scene, camera);
        return;
      }

      if (gameActive) {
        taneGroup.position.x += (targetX - taneGroup.position.x) * 0.1;
        taneGroup.rotation.z = (taneGroup.position.x - targetX) * 0.2;
        taneGroup.rotation.y = (targetX - taneGroup.position.x) * -0.5;

        taneGroup.position.y += playerVelocityY;
        playerVelocityY -= GRAVITY;

        if (taneGroup.position.y > highestY) {
          highestY = taneGroup.position.y;
          updateScore();
        }

        if (playerVelocityY < 0) {
          for (let p of platforms) {
            if (Math.abs(p.x - taneGroup.position.x) < 1.3 &&
              Math.abs(p.y - taneGroup.position.y) < 0.5) {

              playerVelocityY = JUMP_FORCE;
              playJumpSound(); // Play bounce sound!
              spawnParticles(taneGroup.position);
              taneGroup.scale.set(1.2, 0.8, 1.2);
              break;
            }
          }
        }

        taneGroup.scale.lerp(DEFAULT_SCALE, 0.1);

        if (taneGroup.position.y > cameraTargetY - 1) {
          cameraTargetY = taneGroup.position.y + 1;
        }
        camera.position.y += (cameraTargetY - camera.position.y) * 0.1;

        clouds.forEach(c => {
          if (c.position.y < camera.position.y - 20) {
            c.position.y = camera.position.y + 20 + Math.random() * 10;
            c.position.x = (Math.random() - 0.5) * 40;
          }
        });

        if (platforms.length > 0 && platforms[0].y < camera.position.y - 10) {
          // Recycle platform back to pool for reuse
          recyclePlatform(platforms[0]);
          platforms.shift();
          generateNextPlatform();
        }

        if (taneGroup.position.y < camera.position.y - 8) {
          gameOver();
        }

        for (let i = particles.length - 1; i >= 0; i--) {
          let p = particles[i];
          p.mesh.position.add(p.vel);
          p.life--;
          p.mesh.scale.multiplyScalar(0.9);
          if (p.life <= 0) {
            // Recycle particle back to pool for reuse
            recycleParticle(p);
            particles.splice(i, 1);
          }
        }
      } else {
        taneGroup.rotation.y += 0.02;
        taneGroup.position.y = Math.sin(Date.now() * 0.003) * 0.5;
      }

      renderer.render(scene, camera);
    }

    init();
  </script>
</body>

</html>